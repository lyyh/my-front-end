## js事件代理机制
1. 解决父元素的动态生成的子元素较多时的监听器绑定麻烦问题（无法绑定动态生成的dom节点）
2. 解决性能上的问题，为每一个dom节点绑定一个EventHandler会对页面性能造成极大的负担，因为每一个EventHandler都会占用内存  


### js的冒泡机制
基本上所有的浏览器都支持事件冒泡。当在某个DOM节点上触发事件上，事件会一直向上传递，一直到文档的根节点。既然所有的节点的事件最终都会传递到文档根节点，那么我们如果直接将事件绑定到文档根节点（document节点），然后通过event.target来判断是哪个节点触发的事件，是不是减少很多EventHandler的绑定呢？

## js事件冒泡和捕获
在元素1中嵌套元素2，并且两者都有一个onClick事件处理函数(event handler),如果用户单击元素2，则元素1和元素2的单击事件都会被触发。但是哪一个事件先被触发？哪一个事件处理函数会被首先执行？换句话说，事件的发生顺序到底如何？

### DOM事件流
三个阶段:  
1. 事件捕获阶段
2. 处于目标阶段
3. 事件冒泡阶段

### 两种模型：
不出所料，在那些“不堪回首”（浏览器大战）的日子里，Netscape和微软有两种截然不同的处理方法：   

Netscape主张元素1的事件首先发生，这种事件发生顺序被称为捕获型  
微软则保持元素2具有优先权，这种事件顺序被称为冒泡型  

这两种事件顺序是截然相反的。Explorer浏览器只支持冒泡事件，Mozilla，Opera7和Konqueror两者都支持。而更古老的opera和iCab两者都不支持  

### 事件捕获
当鼠标点击或者触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。  
### 事件冒泡
与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。
### dom标准事件流
触发的先后顺序:先捕获再冒泡，即当触发dom事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡。不同的浏览器对此有着不同的实现，IE10及以下不支持捕获型事件，所以就少了一个事件捕获阶段，IE11、Chrome 、Firefox、Safari等浏览器则同时存在。    
dom标准事件流的触发的先后顺序为：先捕获再冒泡，即当触发dom事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡。不同的浏览器对此有着不同的实现，IE10及以下不支持捕获型事件，所以就少了一个事件捕获阶段，IE11、Chrome 、Firefox、Safari等浏览器则同时存在。    
### DOM2 Level Event
DOM2级事件中规定的事件流包括三个阶段:捕获阶段、处于目标阶段和冒泡阶段  
捕获阶段 目标阶段 冒泡阶段

#### 事件源
这里的事件源值的是实际触发的DOM节点,点击DOM节点的时候首先就找到了事件源  

### W3C 模型

W3c明智的在这场争斗中选择了一个择中的方案。任何发生在w3c事件模型中的事件，首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段  

                 | |  / \
-----------------| |--| |-----------------
| element1       | |  | |                |
|   -------------| |--| |-----------     |
|   |element2    \ /  | |          |     |
|   --------------------------------     |
|        W3C event model                 |
------------------------------------------
为一个web开发者，你可以选择是在捕获阶段还是冒泡阶段绑定事件处理函数，这是通过addEventListener()方法实现的，如果这个函数的最后一个参数是true，则在捕获阶段绑定函数，反之false，在冒泡阶段绑定函数。  

### （事件在这里就像一个观光客，由外至内游览，逐渐接近被触发的主要元素，然后又反向离开）
单击事件首先进入捕获阶段开始（逐渐接近元素2的方向）。查看元素2的祖先元素中是否有在捕获阶段有onclick处理函数的  
发现元素1有一个，于是doSomething2被执行  
事件检查到目标自己（元素2），捕获阶段没有发现更多的处理函数了。事件开始进入冒泡阶段，想当然执行doSomething()，这个绑定于元素2冒泡阶段的函数。  
事件向远离元素2的方向，查看是否有任何祖先元素在冒泡阶段绑定了一个处理函数。没有这样的情况，所以什么也没有发生  

### 两个事件绑定方法
#### addEventListener
addEventListener在Chrome 、Firefox、Safari等浏览器都得到支持。  IE8以上支持
#### attachEvent
attachEvent主要用于IE浏览器，并且仅在IE10及以下才支持，IE11已经废了这个方法了（微软还是挺识趣的，慢慢向标准靠拢）。   

事件处理函数中，我们通常使用this来获取当前被操作的对象。这无疑是很方便的一个特性， 但对于不同的事件绑定方式，this可能不一定是当前被操作的对象。 本文便来分析不同的方式绑定事件处理函数时，函数中this的区别。常见的事件绑定方式不外乎4种：

attachEvent：IE10以下（不包括IE10）的MSIE中。
addEventListener：支持DOM Level 2 Event的浏览器中。
el.onclick=function(){}：这是古老的事件绑定方式。
<a onclick='handle()'>：这是最古老的事件绑定方式。
jQuery：jQuery也提供了很多方法来方便地绑定事件。
