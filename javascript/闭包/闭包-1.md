## 空闲之余在掘金上看到了一篇闭包的文章，感觉挺不错，让我对闭包进一步加深了认识
### 什么是闭包(closure)？
两种说法：  
一：有权访问另一个函数作用域中的变量的函数  
二：MDN上的解释，闭包是一个特殊的函数，它由两部分组成：函数，及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。

### 闭包的特点
闭包的作用域链包含着它自己的作用域，同时也包含着父作用域和全局作用域  

通常函数的作用域和内部的变量在函数执行完之后会被销毁。但是在创建了一个闭包，并且闭包使用了函数的变量，函数的变量将会一直被保存至闭包不存在为止。  

如果两个对象相互引用，但不被第三者引用，那么这两个相互引用的对象也会被回收。  

闭包这能取到包含函数内任何变量的最后一个值，因为闭包所保存的是整个变量对象，而不是某个特殊的变量。

### 拥有闭包的函数为什么会被保存在内存之中
在闭包中，因为外层函数a被内层函数b引用，内层函数b又被外层函数a之外的全局变量c引用，这就是为什么函数a被执行之后不会被回收的原因。

### 匿名函数的最大用途
创建闭包，并且还可以构建命名空间，以减少全局变量的使用。从而使用闭包模块化代码，减少全局变量的污染

### 闭包的缺陷
1. 常驻内存会增大内存的使用量，并且使用不当会很容易造成内存泄漏
2. 在没有必要的情况下，创建闭包是不明智的。因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。

### 在函数外调用闭包的影响：增加内存占用
在正常情况下，函数调用结束之后就函数的执行环境就会离开执行栈，定义的变量废弃(废弃与垃圾回收机制有关)，，活动变量（变量对象）会被销毁，内存释放。但是现在因为闭包的作用域链包含了外部函数的变量对象，外部函数的变量有可能再被引用，垃圾收集机制不会将外部函数的变量废弃，在内存保留的外部函数的变量对象。这样就加大了对内存的占用。


### 闭包与变量的关系
#### 闭包保存的是包含函数的整个变量对象，所取得的外部对象变量为闭包被调用时刻的对象变量，一般为外部函数变量的最后一个值。
```
function createFun() {
    var result = [];
    for ( var i = 0; i < 10; i++) {
        result[i] = function() {
            return i;
        };
    }
    return result;
}
var result = createFun();
console.log(result[5]()); // 10
```
　　这里外部函数的返回值为一个数组，数组值为不同函数（闭包）的引用，我们会误认为每个闭包的调用的返回值不同，但实际上每个函数都会返回一样的值。因为当闭包调用时，调用闭包的外部函数已经执行完毕，此时外部函数的变量对象中的 i = 10，而我们闭包的返回值为i，闭包会获取调用时的外部变量对象，此时的i为10。

解决：
```
function createFun() {
    var result = [];
    for ( var i = 0; i < 10; i++) {
        result[i] = function(num) {
            return function() {
                   return num;
            };   
         }(i);
    }
    return result;
}
var result = createFun();
console.log(result[5]()); // 5  
```   


　　在循环中，我们定义了一个匿名数组，并将立即执行该匿名函数的结果赋给数组，这里的匿名函数有一个参数num，每次将i作为参数传递给num，每次循环num都会得到不同的值，所以每次返回了不同的函数（区别在于num值不同），当在外部调用数组值时，会返回不同的值，与预期相符。　






