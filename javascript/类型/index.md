## 基本数据类型
#### boolean number string undefined null  
对null类型进行typeof操作得到的结果为“object”，然而，ECMAScript标准描述其为一个独特的类型。  

## 基本包装类型
为了便于操作基本类型值，ECMAScript还提供了三个特殊的引用类型：Boolean、Number和String,标准库提供了构造函数来封装布尔值、数字和字符串作为对象。这些类型与其他引用类型相似，同时也具有与各自的基本包装类型相应的特殊行为。实际上，每当读取一个基本类型值时，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。  
#### 而在读取模式中访问字符串时，后台都会自动完成下列处理：
1.创建String类型的一个实例。  
2.在实例上调用指定方法。  
3.销毁这个实例  
```
    var s1 = new String('hello');
    var s2 = s1.substring(2);
    s2 = null;
```


### 引用类型和基本包装数据类型的声明周期
引用类型与基本包装类型的主要区别就是对象的生命周期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，只存在于这一行代码的执行期(瞬间)，然后立即销毁。这就意味着我们不能在运行时为属性添加属性和方法。  
```
var s1 = "some text";
s1.color = "red";
alert(s1.color); //undefined
```

#### 值得注意的是，使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。
```
var value = "25";
var number = Number(value);//转型函数
alert(typeof number) //number

var obj = new Number(var); //构造函数
alert(typeof obj) //object
```

###  基本数据类型的特点
#### 基本数据类型的值不可改变
#### 基本数据类型的比较是值的比较
只有在它们的值相等的时候它们才相等。  
```
var a = 1;
var b = true;
console.log(a == b);//true
```

它们不是相等吗？其实这是类型转换和 == 运算符的知识了，也就是说在用==比较两个不同类型的变量时会进行一些类型转换。像上面的比较先会把true转换为数字1再和数字1进行比较，结果就是true了。 这是当比较的两个值的类型不同的时候==运算符会进行类型转换，但是当两个值的类型相同的时候，即使是==也相当于是===。


#### 引用类型的特点
对象是属性和方法的集合。也就是说引用类型可以拥有属性和方法，属性又可以包含基本类型和引用类型。来看看引用类型的一些特性：  
#### 引用类型的值是可以改变的
#### 引用类型的值是同时保存在栈内存和堆内存中的对象
准确地说，引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址。 


#### 简单赋值
在从一个变量向另一个变量赋值基本类型时，会在该变量上创建一个新值，然后再把该值复制到为新变量分配的位置上：这两个变量可以参加任何操作而相互不受影响。    
#### 引用赋值
当从一个变量向另一个变量赋值引用类型的值时，同样也会将存储在变量中的对象的值复制一份放到为新变量分配的空间中。前面讲引用类型的时候提到，保存在变量中的是对象在堆内存中的地址，所以，与简单赋值不同，这个值的副本实际上是一个指针，而这个指针指向存储在堆内存的一个对象。那么赋值操作后，两个变量都保存了同一个对象地址，则这两个变量指向了同一个对象。因此，改变其中任何一个变量，都会相互影响：  