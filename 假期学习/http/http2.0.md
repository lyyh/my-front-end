## http2.0 vs http1.1


### http1.1管线化(pipelining)
http1.1管线化技术，多个http请求可同时在一个TCP分组里面批量发送  
1.pipelining只能适用于http1.1，一般来说，支持http1.1的server都要求支持pipelining  
2.只有幂等的请求（GET，HEAD）能使用pipelining，非幂等请求比如POST不能使用，因为请求之间可能会存在先后依赖关系。  
3.head of line blocking并没有完全得到解决，server的response还是要求依次返回，遵循FIFO(first in first out)  4.原则。也就是说如果请求1的response没有回来，2，3，4，5的response也不会被送回来。  
5.绝大部分的http代理服务器不支持pipelining。  
6.和不支持pipelining的老服务器协商有问题。  
7.可能会导致新的Front of queue blocking问题。 

### HTTP2.0的优势
相比 HTTP/1.x，HTTP/2 在底层传输做了很大的改动和优化：  
1.HTTP/2 采用二进制格式传输数据，而非HTTP/1.x的文本格式。二进制格式在协议的解析和优化扩展上带来更多的优势和可能。  
2.HTTP/2 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量。而 HTTP/1.x 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。头压缩能够很好的解决该问题。
多路复用，直白的说就是所有的请求都是通过一个 TCP 连接并发完成。HTTP/1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。同时，流还支持优先级和流量控制。
Server Push：服务端能够更快的把资源推送给客户端。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。
HTTP/2 主要是 HTTP/1.x 在底层传输机制上的完全重构，HTTP/2 是基本兼容 HTTP/1.x 的语义的(详细兼容性说明请戳这里)。Content-Type 仍然是 Content-Type，只不过它不再是文本传输了。那么 HTTP/2 的这些新特性又是如何实现的呢？
### 多路复用
多路复用通过多个请求stream共享一个tcp连接的方式，解决了http1.x holb（head of line blocking）的问题，降低了延迟同时提高了带宽的利用率。  

### 压缩头部
HTTP/2.0规定了在客户端和服务器端会使用并且维护「首部表」来跟踪和存储之前发送的键值对，对于相同的头部，不必再通过请求发送，只需发送一次。事实上,如果请求中不包含首部（例如对同一资源的轮询请求），那么首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部。    
如果首部发生变化了，那么只需要发送变化了数据在Headers帧里面，新增或修改的首部帧会被追加到“首部表”。首部表在 HTTP2.0的连接存续期内始终存在,由客户端和服务器共同渐进地更新。

### 二进制分帧
在应用层与传输层之间增加一个二进制分帧层，以此达到“在不改动HTTP的语义，HTTP 方法、状态码、URI及首部字段的情况下，突破HTTP1.1的性能限制，改进传输性能，实现低延迟和高吞吐量。”  

在二进制分帧层上，HTTP2.0会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。  

客户端和服务器可以把HTTP消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。注意，同一链接上有多个不同方向的数据流在传输。客户端可以一边乱序发送stream，也可以一边接收者服务器的响应，而服务器那端同理。  

在共享的连接上可以同时发送请求和响应  

### 请求优先级
多路复用导致所有资源都是并行发送，那么就需要「优先级」的概念了，这样就可以对重要的文件进行先传输，加速页面的渲染。  

### 服务器推送
服务器推送是指在客户端请求之前发送数据的机制。  

另外有一点值得注意的是，客户端如果退出某个业务场景，出于流量或者其它因素需要取消server push，也可以通过发送RST_STREAM类型的frame来做到。  



### 参考资料
[前端应该知道的HTTP](https://segmentfault.com/a/1190000005085636)  


