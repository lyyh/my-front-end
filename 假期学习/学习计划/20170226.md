定时函数 setTimeout 和 setInterval 都可以接受字符串作为它们的第一个参数。 这个字符串总是在全局作用域中执行，因此 eval 在这种情况下没有被直接调用。

eval存在作用域不稳定和安全问题  

对于:hover在IE6下只有a元素支持，:active只有IE7-6不支持，:focus在IE6-7下不被支持。著作权归作者所有。


验证令牌ETag，在响应过期之后，可以用来验证资源是否被修改。客户端自动在If-None-MatchHTTP 请求头中提供 ETag 令牌，服务器针对当前的资源检查令牌，如果未被修改过，则返回304 Not Modified响应，告诉浏览器缓存中的响应未被修改过，可以再延用 120 秒。  

Cache-Control HTTP 头来定义自己的缓存策略。Cache-Control 指令控制谁在什么条件下可以缓存响应以及可以缓存多久  

Cache-Control 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires）。当前的所有浏览器都支持 Cache-Control，因此，使用它就够了。  

Cache-Control public响应可以被缓存，public不是必须的，因为明确的缓存信息（例如max-age）已表示 响应可以被缓存。private,浏览器可以缓存private响应，但是通常只为单个用户缓存，因此，不允许任何中继缓存对其进行缓存 - 例如，用户浏览器可以缓存包含用户私人信息的 HTML 网页，但是 CDN 不能缓存。只能使用本地缓存

max-age响应过期时间
该指令指定从当前请求开始，允许获取的响应被重用的最长时间（单位为秒） - 例如：max-age=60表示响应可以再缓存和重用 60 秒。

Cache-Control指令
max-age=86400   浏览器和任何中继缓存均可以将响应（如果是`public`的）缓存长达一天（60 秒 x 60 分 x 24 小时）
private, max-age=600    客户端浏览器只能将响应缓存最长 10 分钟（60 秒 x 10 分）
no-store    不允许缓存响应，每个请求必须获取完整的响应。  

浏览器发出的所有 HTTP 请求会首先被路由到浏览器的缓存，以查看是否缓存了可以用于实现请求的有效响应。如果有匹配的响应，会直接从缓存中读取响应，这样就避免了网络延迟以及传输产生的数据成本。  

服务器端更新资源后如何让客户端缓存和快速更新，在响应未过期的情况下。使用版本号
很简单，在资源内容更改时，我们可以更改资源的网址，强制用户下载新响应。通常情况下，可以通过在文件名中嵌入文件的指纹码（或版本号）来实现 - 例如 style.x234dff.css。  

组合使用 ETag、Cache-Control 和唯一网址，我们可以提供最佳的方案：较长的过期时间，控制可以缓存响应的位置，以及按需更新  

如果Pragma头部和Expires头部同时存在，则起作用的会是Pragma，有兴趣的同学可以自己试一下。
需要注意的是，响应报文中Expires所定义的缓存时间是相对服务器上的时间而言的，其定义的是资源“失效时刻”，如果客户端上的时间跟服务器上的时间不一致（特别是用户修改了自己电脑的系统时间），那缓存时间可能就没啥意义了。  

，比如设置的缓存时间未过期，那么自然直接从本地缓存取数据即可（在chrome下表现为200 from cache），若缓存时间过期了或资源不该直接走缓存，则会发请求到服务器去。  

避免了网络延迟和数据传输成本  


