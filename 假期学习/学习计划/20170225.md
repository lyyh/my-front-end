一个常见的误解是数字的字面值（literal）不能当作对象使用。这是因为 JavaScript 解析器的一个错误， 它试图将点操作符解析为浮点数字面值的一部分。
2.toString();// 出错：SyntaxError  

hasOwnProperty 所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。  

对象不能直接被delete，对象的属性可以被delete  

将原子类型赋给prototype的操作将会被忽略，而将对象赋值给prototype，会动态的创建原型链。  

原型链上性能的影响：如果一个属性在原型链的上端，则对于查找时间将带来不利影响。特别的，试图获取一个不存在的属性将会遍历整个原型链。  

当使用 for in 循环遍历对象的属性时，原型链上的所有属性都将被访问。

提防原型链过长带来的性能上的问题，并知道如何缩短原型链来提高性能。hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。  

注意: 通过判断一个属性是否 undefined 是不够的。 因为一个属性可能确实存在，只不过它的值被设置为 undefined。  

JavaScript 不会保护 hasOwnProperty 被非法占用  

和 in 操作符一样，for in 循环同样在查找对象属性时遍历原型链上的所有属性。  

由于 var 定义了一个声明语句，对变量 foo 的解析是在代码运行之前，因此 foo 变量在代码运行时已经被定义过了。  
但是由于赋值语句只在运行时执行，因此在相应代码执行之前， foo 的值缺省为 undefined。  

命名函数的赋值表达式  
```
var foo = function bar() {
    bar(); // 正常运行
}
bar(); // 出错：ReferenceError
```
bar 函数声明外是不可见的，这是因为我们已经把函数赋值给了 foo； 然而在 bar 内部依然可见。这是由于 JavaScript 的 命名处理 所致， 函数名在函数内总是可见的。  

当使用 Function.prototype 上的 call 或者 apply 方法时，函数内的 this 将会被 显式设置为函数调用的第一个参数。  

虽然 this 的晚绑定特性似乎并不友好，但这确实是基于原型继承赖以生存的土壤。  




