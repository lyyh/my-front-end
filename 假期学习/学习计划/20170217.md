web worker无法使用浏览器的相关资源，所以无法进行DOM操作  
buffer类似于一个整数数组，是v8堆内存之外的一块原始内存  
当浏览器获得一个html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。  
defer 属性规定是否对脚本执行进行延迟，直到页面加载为止。

Object.create(prototype,descriptors);
prototype
必需。  要用作原型的对象。  可以为 null。  
descriptors
可选。  包含一个或多个属性描述符的 JavaScript 对象。 

Object.create(null) {} 前者原型链短  

优化css计算样式。减少dom深度，id选择器可以唯一确定一个元素，不要给类选择器指定标签，类选择器尽量代表一类属性 
避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;#tp p{} 子选择符：#tp>p{}
避免使用通配符，举一个例子，.mod .hd *{font-size:14px;} 根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配.hd（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配.mod,这样的性能耗费可想而知.  

当onload事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。
当DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。
我们需要给一些元素的事件绑定处理函数。但问题是，如果那个元素还没有加载到页面上，但是绑定事件已经执行完了，是没有效果的。这两个事件大致就是用来避免这样一种情况，将绑定的函数放在这两个事件的回调中，保证能在页面的某些元素加载完毕之后再绑定事件的函数。  

浏览器预加载js，但不会立即执行下载后的内容  

Window.getComputedStyle() 方法在应用活动样式表并解析这些值可能包含的任何基本计算后，给出一个元素的所有CSS属性的值。

加载样式表会阻塞外链脚本的执行.js会阻塞html、css渲染渲染

可以发现，浏览器是并行发起css、图片、js的请求，当hh.js被延时后，并不会影响其他资源与服务器之间的响应。页面阻塞期间，我在source资源下搜索了bb.js,发现并没有,说明js的加载会阻塞其他资源的加载。  在resource资源卡下，会发现bb.js还有其他资源其实已经被下载，这个现象就说明了浏览器存在优化现象，在之前那篇笔记中也提到过Prefetch，虽然浏览器进行预加载，但是并不会执行下载后的内容，而是把这个留给真正该加载的时候 ，也就是 延时的js执行之后。  

浏览器可以并行发送请求，但是加载会阻塞其他资源的加载  

页面的渲染 需要首先生成dom树，再由css生成CSSOM，最后两个一起生成render tree。由前面两个例子 可以证明dom树有最小的生成要求，及只要body标签被生成，dom树就可以和CSSOM一起进行渲染啦。  

总听到 有人会建议 要求 将script标签放到body底端，的确 这样不会影响dom树的构建，不会影响渲染树的生成，不会阻塞其他资源的下载，但是一定要这样么，script元素有async属性，可以使得script的加载为异步（向服务器端发起请求都是异步的），不会阻塞其他资源的下载，