node单线程只是javascript执行线程，实际的IO操作是多线程执行的。  
libuv为Node.js提供了跨平台、线程池、事件池、异步IO等能力。是一个对用户友好的工具集，包含定时器，非阻塞的网络 I/O，异步文件系统访问，子进程等功能。它封装了 Libev、Libeio 以及 IOCP，保证了跨平台的通用性。 
 Node.js并不是一门语言，而是一个平台， 通过V8引擎解析之后，使用C/C++来执行真正的系统调用  
将IO请求发送传递给Libuv后，Libuv开启线程来执行本次IO调用  
Node.js 并没有给 Javascript 执行时创建新线程的能力，最终的实际操作，还是通过 Libuv 以及它的事件循环来执行的。这也就是为什么 Javascript 一个单线程的语言，能在 Node.js 里面实现异步操作的原因  
timer定时器，并没有独立开启新的线程，而是在事件循环队列中直接完成。  
事件循环除了维护哪些观察者队列，还维护了一个time字段，用来处理定时器的回调。  
浏览器并行发起对文件的请求  

css文件的加载不影响js文件的加载，但却影响js文件的执行  
js文件在加载的同时也在解析  

渲染的最大困难就是为每一个dom节点计算符合他们的最终样式。为每个元素查找到匹配的样式规则表，需要遍历整个规则表   
构建渲染树的过程，是原来DOM树的可视化表示，构建这棵树是为了以正确的顺序绘制文档的内容。为每一个元素查找到匹配的样式规则，需要遍历整个规则表  

webkit渲染是一个元素与样式规则匹配的过程，Gecko则需要构建样式计算规则书，然后与dom树对应生成样式上下文数（及渲染树）Gecko利用样式规则树，有效的实现了样式共享。Webkit没有规则树，则需要对css解析结果进行多次遍历。出现多次的属性将会被按照正确的级联顺序进行处理最后一个生效。

