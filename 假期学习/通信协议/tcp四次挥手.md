## tcp四次挥手
假设主机A为客户端，主机B为服务器。
1.第一次，首先A向B发送一个FIN,用来关闭A与B之间的连接，然后等待服务器的确认，终止标志位为FIN=1,序列号为seq=w。  
2.第二次，服务器收到这个FIN,它发回一个ACK,确认号ack收到的序号+1.服务器进入close-wait状态，此时TCP服务器进程就通知高层应用进程，此时是“半关闭”状态，A不能向B发送数据，B能向A发送数据。    

3.第三次，B向A发送一个FIN,关闭B与A之间的连接。此时，若B没有数据报要发送给A了，其应用进程就通知TCP释放连接，然后发送给A连接释放报文段，并等待确认。A发送确认后，进入time-wait，注意，此时TCP连接还没有释放掉，然后经过时间等待计时器设置的2MSL后，A才进入到close状态。  

4.客户段收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加1。  
首先进行关闭的一方主动关闭，另一方被动关闭  

### 为什么要等待2MSL?
MSL表示最大报文生存时间。他是p任何报文在网络上存在的最长时间，超过这个时间报文将会被丢弃。第四次握手的时候，A发送ACK包进入TIME_WAIT状态，必须在此状态上停留两倍的MSL时间  
原因：  
怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。  

①为了保证A发送的最后一个ACK报文段能够到达B。即最后这个确认报文段很有可能丢失，那么B会超时重传，然后A再一次确认，同时启动2MSL计时器，如此下去。如果没有等待时间，发送完确认报文段就立即释放连接的话，B就无法重传了（连接已被释放，任何数据都不能出传了），因而也就收不到确认，就无法按照步骤进入CLOSE状态，即必须收到确认才能close。    
②、防止“已失效的连接请求报文段”出现在连接中。经过2MSL，那些在这个连接持续的时间内，产生的所有报文段就可以都从网络中消失。即在这个连接释放的过程中会有一些无效的报文段滞留在楼阁结点，但是呢，经过2MSL这些无效报文段就肯定可以发送到目的地，不会滞留在网络中。这样的话，在下一个连接中就不会出现上一个连接遗留下来的请求报文段了。    
可以看出：B结束TCP连接的时间比A早一点，因为B收到确认就断开连接了，而A还得等待2MSL.  

### 为什么TCP释放连接需要四次？
TCP建立连接需要三次握手，而断开连接需要四次。是因为TCP的半关闭状态造成的。因为TCP连接是双工的（即数据可以在两个方向上传递）所以进行关闭时，每个方向上都要单独进行关闭，这种单方向上的关闭叫做半关闭状态。当一方要完成他的数据发送任务，就要发送一个FIN来向另一方通知要终止这个方向的连接。  


ps:
  1）发送了FIN只是表示这端不能继续发送数据(应用层不能再调用send发送)，但是还可以接收数据。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据，比如：如主机A收到主机B的FIN断开TCP连接请求，只是表示主机B已经发送完数据，主机A收到FIN后作出应答，并终止这个方向的数据传输，此时处于半关闭状态。但是主机A仍然可以发送数据的，只有当主机A发送完数据并发送FIN给主机B时，主机B才停止这个方向的数据传输，并关闭TCP连接。  
  2)）在很多时候，TCP连接的断开都会由TCP层自动进行，例如你CTRL+C终止你的程序，TCP连接依然会正常关闭，你可以写代码试试。
