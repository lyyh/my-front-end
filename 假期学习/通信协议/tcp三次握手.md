## tcp三次握手
1.第一次握手：客户端发送SYN包(SYN=j)到服务器，进入SYN_SENT状态，然后等待服务器确认；  
2.第二次握手：服务器接收到SYN包后，必须确认客户的SYN(ack=j+1),同时自己也会发送一个SYN包(syn=k),即SYN+ACK包，服务器进入SYN_RECV状态  
3.第三次握手：客户端接收到SYN+ACK包之后，随即向服务器发送SYN(ack=k+1),同时服务器和客户端都进入ESTABLISHED状态  

序列号seq:占四个字节，用来标记数据段的顺序。seq把连接中发送的所有数据都编上一个序号，给字节编上一个序号之后，就给每一个报文段指派一个序号，seq序号就是报文段中第一个字节的数据编号。  

确认号ack:占四个字节，期待收到对方下一个报文段的第一个数据字节的序号。因此，当前报文段最后一个字节的编号+1即为确认号。  

确认ACK:占1位，仅当ack=1时，确认号字段才有效，若ack=0，则确认号无效。  
终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接  
同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。  

PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。 

## tcp建立三次握手
1.第一次，主机A向主机B发送TCP连接请求数据包，其中包含主机A的初始序列号seq(A)=x。（其中报文中同步标志位SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x）；主机A的状态为SYN_SEND  

2.第二次，主机B收到请求后，会发回连接确认数据包(其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含主机B的初始序列号seq(B)=y，以及主机B对主机A初始序列号的确认号ack(B)=seq(A)+1=x+1)主机B的状态为SYN_RECVD，主机A的状态为ESTABLISHED.  

3.第三次，主机A收到主机B的确认报文后，还需要做出确认，发送一个序列号seq(A)=x+1,确认号为ack(A)=y+1的报文)，主机B的状态为ESTABLISHED.   


## 为什么要用三次握手
防止已经失效的连接请求报文又突然发送到了B。    
如果没有三次握手，已经失效的连接被B接收后，B会认为是A又发送了一次请求报文段，于是发送了一次确认报文段，会导致又建立了一个连接。但是此时A收到B的确认后，并不会理睬，到时B一直等待A将数据发送给自己，此时B的资源就白白浪费掉了。但是采用三次握手的话，A没有发送确认，B因为没有收到确认就不会建立连接。  

参考资料：http://blog.csdn.net/guyuealian/article/details/52535294



