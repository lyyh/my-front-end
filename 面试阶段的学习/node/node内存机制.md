## Node内存控制
Node.js基于无阻塞、事件驱动，不用考虑线程的创建和销毁以及上下文切换，低内存消耗。但是在海量请求和长时间运行的条件下需要讨论内存控制。   

### Node的内存分配
在启动Node应用程序的时候，可以为应用程序初始化堆内存空间，同时在初始化之后无法更改。v8堆内存在64位下最大内存为1464MB，其中老生代内存空间为1400MB，新生代在复制的方式下需要两倍的32MB空间。v8堆内存在32位下最大内存为732MB，其中老生代内存空间位700MB，新生代在复制的方式下需要两倍的16MB空间.    
限制v8内存的原因是v8垃圾回收机制的限制。对过大的内存进行Node垃圾回收，会造成javascript线程暂停执行的时间增强。   

### Node垃圾回收机制
Node的垃圾回收机制主要基于分代式垃圾回收机制。根据对象的存活周期不同，分为新生代(存活时间较短的对象),老生代(存活时间较长的对象)

#### 回收机制算法
Scavenage:  
Scavenage算法，主要采用了Cheney算法，使用复制的方式实现垃圾回收机制。将新生代的堆内存空间分成两个部分，第一个部分就是处于使用状态From空间，第二个部分是处于闲置状态的To空间。显示在From空间里面分配内存，然后在垃圾回收的时候，检查From空间内的存活对象，这些存活对象将会被复制到To内存空间里面去，从而释放掉了无用的空间(非存活空间所占的内存)。完成复制之后，From空间和To空间将会被对换。  

如果当一个对象经过多次复制依然存活的时候，会被认为是生命周期长的对象，会被移入到老生代中，这种移入被称为晋升。对象晋升的条件主要有两个，一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。  

对象晋升:
1.在从From空间复制到To空间的过程中，判断存活对象是否经历了Scavenge回收，如果经历了回收，就会晋升。
2.To空间的占用比，在复制过程中，如果To空间的占用比超过了25%，剩下的存活对象就会晋升。原因是在To空间变成From空间之后，会进行内存分配，如果占用过高，会影响内存分配。  


缺点:  
只能使用堆内存中的一半，但是由于Scavenage只复制存活的对象，并且存活周期短的对象少，在时间效率上更有优势。
特点:  
典型的牺牲空间获取时间的算法。    

Mark-Sweep&Mark-Compact:  
对于老生代中的对象，由于存活对象占用比较多，复制对象的效率就会比较低，另一个是资源空间浪费一般的问题。  

Mark-Sweep标记清除。分为标记和清除阶段，Mark-Sweep在标记阶段遍历堆中所有的对象，并标记活着的对象。随后在清除阶段，清除未被标记的对象。Scavenge中复制活着的对象，而Mark-Sweep则会清除未被标记的对象。   

Mark-Sweep最大的问题就是在进行一次标记清除回收之后，内存空间会出现不连续的状态，这种内存碎片会对后续的内存分配造成影响。很可能会出现这个时候要分配一个大的对象，但是这时所有的碎片空间都无法完成此次分配，就会提前触发内存回收。   

Mark-Compact标记整理，在对象在标记为死亡之后，在整理的过程中，将活着的对象往一端移动，移动完成之后，直接清理掉边界外的内存。移动完成之后，可以直接清除一端的空洞。  


Increamental Marking  
在标记阶段，使垃圾回收与应用逻辑交替执行。延迟清理、增量式整理，并行标记与并行整理，进一步利用多核性能降低每次停顿的事件。  


想要高性能的执行效率，要让垃圾回收尽量少的执行，尤其是全堆垃圾回收。  











