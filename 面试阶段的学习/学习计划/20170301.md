如果代码中设定了一个 setTimeout，那么浏览器便会在合适的时间，将代码插入任务队列，如果这个时间设为 0，就代表立即插入队列，但不是立即执行，仍然要等待前面代码执行完毕。所以 setTimeout 并不能保证执行的时间，是否及时执行取决于 JavaScript 线程是拥挤还是空闲。  

这是涉及到浏览器引擎的一个 event loop 机制 event loop 是一个回调函数的队列 当你对setTimeout 或者 对DOM 节点进行操作的时候 浏览器引擎会把他交给 wep api, wep api操作完之后 会把你的回调函数放进 event loop 里面 当你的调用栈 (call stack) 为空的时候 event loop 才会把回调函数顶上去调用栈里调用运行

浏览器至少有三个线程:javascript引擎线程、GUI渲染线程、浏览器事件触发线程  


异步模型:
dom事件，ajax,timer，requestAnimationFram,promise,  

setTimeout(0),setImmediate,requestAnimationFrame,promise  


而且Promise的延迟比setImmediate更低，意味着Promise比setImmediate先执行。  
尽管setImmediate的回调函数比Promise先注册，但还是Promise先执行。
可以肯定的是，在各JS环境中，Promise都是最先执行的，setTimeout(0)、setImmediate和requestAnimationFrame顺序不确定。   

Process.nextTick
process.nextTick是Nodejs的API，比Promise更早执行。
事实上，process.nextTick是不会进入异步队列的，而是直接在主线程队列尾强插一个任务，虽然不会阻塞主线程，但是会阻塞异步任务的执行，如果有嵌套的process.nextTick，那异步任务就永远没机会被执行到了。
使用的时候要格外小心，除非你的代码明确要在本次事件循环结束之前执行，否则使用setImmediate或者Promise更保险。  

no-cache必须先向服务器确认返回的响应是否被更改，才能使用该响应来满足后续对统一网址的请求。  因此，如果存在合适的验证令牌(ETag)，no-cache会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。    

304

### 需要学习的
TLS/SSL
