创建实例的四个阶段:创建、赋值作用域、执行、返回    

传统BS架构模式由Web服务器端做模板和数据的拼装，组装成HTML页面之后再返回给浏览器。最后浏览器再对页面进行渲染    
SPA应用只有在初始化的重新加载页面，一旦加载完成，页面不会因为用户的操作而重新加载，利用js动态地改变页面部分，不需要重新渲染这个页面，提高了流畅的用户体验。  
  

SPA优点:
后端更专注于业务逻辑，数据安全存储，前端更专注于用户体验，页面逻辑  
前后端开发可以并行开发
减轻服务器压力  
SEO只能抓取首页，通过hash值变换不能保存在搜索引擎的抓取记录中。  
浏览器历史记录，只能记录首页    

一个字符串与一个数字相加，会调用数字对象的toString方法。  

遇到算数运算符(- 、* 、/ 和 %)的时候会在运算之前将参与运算的双方转换成数字。    

需要强调的是，在 Javascript 中，只有 空字符串、数字0、false、null、undefined 和 NaN 这 6 个值为假之外，其他所有的值均为真值。    

说到 NaN，就不得不提一下 isNaN() 方法，isNaN() 方法自带隐式类型转换，该方法在测试其参数之前，会先调用 Number() 方法将其转换为数字。所以 isNaN('1') 这个语句中明明用一个字符串去测试，返回值仍然为 false 也就不足为怪了。  

当字符串和对象进行 + 运算的时候，Javascript 会通过对象的 toString() 方法将其自身转换为字符串，然后进行连接操作。

"1" + { toString: function() {return 1;} } // "11"
之所以说它特殊，是因为当一个对象同时包含 toString() 和 valueOf() 方法的时候，运算符 + 应该调用哪个方法并不明显(做字符串连接还是加法应该根据其参数类型，但是由于隐式类型转换的存在，类型并不显而易见。)，Javascript 会盲目的选择 valueOf() 方法而不是 toString() 来解决这个问题。这就意味着如果你打算对一个对象做字符串连接的操作，但结果却是......

var obj = {
    toString: function() { return "Object CustomObj"; },
    valueOf: function() { return 1; }
};

console.log("Object: " + obj);    // "Object: 1"


字符与对象，数字与对象，如果对象都有valueOf，则会调用valueOf

意外的引用传递也会引起内存泄漏，引用传递到闭包中被引用了。  


经过测试(ie8) 是先加载父页面onload事件，加载iframe页面的事件。
js动态设置iframe的src话，顺序就不好说了，但src是固定死了的话，应该会是iframe加载完成后边执行iframe的onload边继续加载iframe下面的代码，整个页面加载完成后再执行整个页面的onload的。  

两个iframe加载顺序不同   
没有办法控制
要想控制，你需要在一个iframe的onload事件里去加载另外一个
要想控制，你需要在一个iframe的onload事件里去加载另外一个