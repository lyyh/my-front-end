内存泄漏，考虑DOM树内部或子节点的引用问题。假如你的 JavaScript 代码中保存了表格某一个 <td> 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 <td> 以外的其它节点。实际情况并非如此：此 <td> 是表格的子节点，子元素与父元素是引用关系。由于代码保留了 <td> 的引用，导致整个表格仍待在内存中。保存 DOM 元素引用的时候，要小心谨慎。

定时器闭包会保存变量

generator函数返回的是一个遍历器，也是generator函数的实例，也继承了generator函数prototype属性和方法。
因为g返回的总是遍历器对象，而不是this对象。Generator函数也不能跟new命令一起用，会报错。
使用call方法绑定对象的this，使其返回的是一个正常对象的实例。使用call方法配合generator.prototype，可以将g函数改造成构造函数.
generator是实现状态机的最佳结构，每执行一次就改变一次状态机
上面的Generator实现与ES5实现对比，可以看到少了用来保存状态的外部变量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator之所以可以不用外部变量保存状态，是因为它本身就包含了一个v状态信息，即目前是否处于暂停态。
Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数。  

form表单初始化FormData对象上传文件、FormData对象添加字段上传文件。
FileReader异步读取File或者Blob对象  

Generator流程控制管理
Generator可以在任何对象上部署iterator接口  

arguments是类数组对象，不能使用forEach  

css预处理器，都是用浏览器不能解析的语法编写，并最编译成浏览器能够解析的语法。
css模块化的好处就是：CCS模块将作用域限制于组件中，从而避免了全局作用域的问题。我们再也不用操心为组件寻找一个好的命名了，因为编译过程已经帮你完成了这个任务。
如何工作  
css模块化可以使用global定义全局样式，可以使用extend  

es6中模块都是一个文件，不需要使用module来定义一个模块，在模块中可以使用import和export关键字  

react:
组件类名首字母必须大写，否则会报错，组件类只能包含一个顶层标签，否则也会报错。 

canvas可以被硬件加速，所以可以使用canvas代替DOM来提高性能。
label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 