Object.keys()返回键名 Object.values()返回键值  Object.entrise返回键值对数组 
Object.entrise()  将对象(可以将无序的键值对转化为Map结构)  
对象解构赋值


每次浏览器处理 HTML 标记，都要完成上述各个步骤：将字节转换为字符，确认符号，将符号转换为节点，然后构建 DOM 树。整个过程需要一些时间，处理大量 HTML 时更是如此。HTML中的尖括号<>里面的文本具有特殊的含义，表示的是标记。因此当我们遇到标记，浏览器就会发出一个令牌，这里就是个StatTag:HTML令牌。然后是下一个StatTag:head令牌。这整个流程都由令牌生成器完成。在令牌生成器生成的过程中，与此同时，另一个流程也在消耗这些令牌，并将它们转换成节点对象。


为了构建渲染树，浏览器大致做了如下：

从 DOM 树的根节点开始，遍历每个可见的节点。
某些节点完全不可见（例如 script 标签、meta 标签等），因为它们不会在渲染结果中反映，所以会被忽略。
某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略。比方说，上面例子中的 span 节点，因为该节点有一条显式规则设置了 display:none 属性，所以不会出现在渲染树中。
给每个可见节点找到相应匹配的 CSSOM 规则，并应用这些规则。
发射可见节点，连带其内容及计算的样式。
DOM编程最耗时的地方，重排和重绘，多次访问DOM对于重排和重绘来说，简直不值一提。重排，元素的几何属性和位置变化，重绘，元素的样式改变  

乍一想，元素的样式改变了三次，每次改变都会引起重排和重绘，所以总共有三次重排重绘过程，但是浏览器并不会这么笨，它会把三次修改“保存”起来（大多数浏览器通过队列化修改并批量执行来优化重排过程），一次完成！但是，有些时候你可能会（经常是不知不觉）强制刷新队列并要求计划任务立即执行。获取布局信息的操作会导致队列刷新，比如：

fragment优化性能 DocumentFragments 是一些DOM节点。它们不是DOM树的一部分。通常的使用场景是创建一个文档片段，然后将创建的DOM元素插入到文档片段中，最后把文档片段插入到DOM树中。在DOM树中，文档片段会被替换为它所有的子元素。因为文档片段存在与内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流(reflow)(对元素位置和几何上的计算)。因此，使用文档片段document fragments 通常会起到优化性能的作用scrollTop 元素滚动条内的顶部隐藏部分的高度,可以控制滚动条的高度
clientTop 表示内容区域的左上角相对于整个元素左上角的位置（包括边框）。其兼容性不错，如下：

fragment优化性能 DocumentFragments提供了一个缓冲机制，将DOM节点放在内存之中，当节点都构造完成后，再将DocumentFragment对象添加到页面中，这时所有的节点都会一次渲染出来，这样就能减少浏览器很多的负担，明显的提高页面渲染速度，只触发了一次重排  

当遇到大量节点的时候使用DocumentFragment作为一个优化方案，一般来说，重排只影响渲染树中的一小部分，但也可能影响很大的部分，甚至整个渲染树。  


使用以下步骤可以避免页面中的大部分重排：

使用绝对位置定位页面上的动画元素，将其脱离文档流
让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是页面一个小区域的重绘过程，不会产生重排并重绘页面的大部分内容。
当动画结束时恢复定位，从而只会下移一次文档的其他元素


重排和重绘是DOM编程中耗能的主要原因之一，平时涉及DOM编程时可以参考以下几点：

尽量不要在布局信息改变时做查询（会导致渲染队列强制刷新）
同一个DOM的多个属性改变可以写在一起（减少DOM访问，同时把强制渲染队列刷新的风险降为0）
如果要批量添加DOM，可以先让元素脱离文档流，操作完后再带入文档流，这样只会触发一次重排（fragment元素的应用）
将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。
