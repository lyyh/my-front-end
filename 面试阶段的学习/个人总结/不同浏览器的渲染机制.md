## 浏览器的重要功能  
是将用户选择得web资源呈现出来，从服务器获取请求的资源，在浏览器上选择出来  

1.用户界面－ 包括地址栏、后退/  前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分  
2.浏览器引擎－ 用来查询及操作渲染引擎的接口  
3.渲染引擎－ 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来
4.网络－ 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作  
5.UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口  
6.JS解释器－ 用来解释执行JS代码  
7.数据存储－ 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术  

### 文档对象模型  
一个包含一些文本和一幅图片的普通 HTML 页面。浏览器如何处理此页面？   
1.转换:  
 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。  
2.令牌化:  
浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌，例如，“<html>”、“<body>”，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。    
转化:将html字符串转化成令牌    
3.词法分析:  
发出的令牌转换成定义其属性和规则的“对象”。    
转化:将令牌转换成对象  
4.DOM树构建  
最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。    

总得来说就是将字节转化成htnml字符，将html转化成令牌，再将令牌转化成节点，构建DOM树。  

### css对象模型  
与处理HTML基本一样，CSS 字节转换成字符，接着转换成令牌和节点，最后链接到一个称为“CSS 对象模型”(CSSOM) 的树结构内   

CSSOM为什么具有树结构?
为页面上的任何对象计算最后一组样式，，浏览器都会先从适用于该节点的最通用规则开始（例如，如果该节点是 body 元素的子项，则应用所有 body 样式），然后通过应用更具体的规则（即规则“向下级联”）以递归方式优化计算的样式。  

还请注意，以上树并非完整的 CSSOM 树，它只显示了我们决定在样式表中替换的样式。每个浏览器都提供一组默认样式（也称为“用户代理样式”），即我们不提供任何自定义样式时所看到的样式，我们的样式只是替换这些默认样式  

### 渲染引擎  
渲染引擎 Rendering engines  
本文所讨论得浏览器——Firefox、Chrome和Safari是基于两种渲染引擎构建的，Firefox使用Geoko——Mozilla自主研发的渲染引擎，Safari和Chrome都使用webkit。  

### webkit渲染:  
解析html以构建dom树->构建render树->布局render树->绘制render树 
1.处理 HTML 标记并构建 DOM 树。  
2.处理 CSS 标记并构建 CSSOM 树。  
3.将 DOM 与 CSSOM 合并成一个渲染树。  
4.根据渲染树来布局，以计算每个节点的几何信息。  
5.将各个节点绘制到屏幕上。(利用操作系统的Natice GUI的API绘制)     

生成render树:  
渲染引擎开始解析html，并将标签转化为内容树中的dom节点。接着，它解析外部CSS文件及style标签中的样式信息。这些样式信息以及html中的可见性指令将被用来构建另一棵树——render树。    

render树由一些包含有颜色和大小等属性的矩形组成，它们将被按照正确的顺序显示到屏幕上。    

布局render树:   
Render树构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标。再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。  

为了更好的用户体验，渲染引擎会尽可能的早将内容呈现在屏幕上。并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。   

#### 构建渲染树的大概过程  
1.从 DOM 树的根节点开始遍历每个可见节点。  
2.对于某些不可见(脚本标记、元标记)，不会体现在渲染输出中  
某些元素通过CSS隐藏(display:none)，因此在渲染树中也会被忽略     
3.发射可见节点，连同其内容和计算的样式    

简单提一句，请注意 visibility: hidden 与 display: none 是不一样的。前者隐藏元素，但元素仍占据着布局空间（即将其渲染成一个空框），而后者 (display: none) 将元素从渲染树中完全移除，元素既不可见，也不是布局的组成部分。

匹配css规则树dom树。  
CSS匹配DOM Tree主要是从右到左解析CSS的Selector  
CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，你就会在N多地方看到很多人都告诉你，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去，……

#### 布局阶段  
最终输出的渲染同时包含了屏幕上的所有可见内容及其样式信息。有了渲染树，我们就可以进入“布局”阶段。  
到目前为止，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们尚未计算它们在设备视口内的确切位置和大小---这就是“布局”阶段，也称为“自动重排”  
为弄清每个对象在网页上的确切大小和位置，浏览器从渲染树的根节点开始进行遍历  
布局流程输出的是一个'盒模型'，它会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的绝对像素。所有相对测量值都转换为屏幕上的绝对像素。  

得到渲染树之后，我们只知道哪些元素使可见的以及它们的计算样式。但是尚未计算它们在设备视口内的确切位置和大小。这就是'布局阶段'，也成为自动重排。在布局阶段，浏览器从渲染树的根节点开始遍历。布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸。  

执行渲染树构建、布局和绘制所需的时间将取决于文档大小、应用的样式，以及运行文档的设备：文档越大，浏览器需要完成的工作就越多；样式越复杂，绘制需要的时间就越长（例如，单色的绘制开销“较小”，而阴影的计算和渲染开销则要“大得多”）。  

#### 绘制
将渲染树中的每个节点转换成屏幕上的实际像素。  

如果 DOM 或 CSSOM 被修改，您只能再执行一遍以上所有步骤，以确定哪些像素需要在屏幕上进行重新渲染。

### 两个浏览器之间的差别
webkit把可视化好的可视元素成为Render Tree,用Layout来表示元素的布局  
Gecko把可视化好的可视元素成为Frame Tree，每个元素就是一个frame，元素的布局成为Reflow  

#### webkit
计算样式并生成渲染对象的过程为attachment，每个dom节点有一个attach方法，attachment的过程是同步的，调用新节点的attach方法插入到dom树中。
parser：解析， Render Tree:渲染树 Layout:安排布局    
渲染过程中，webkit使用一个标志位标志所有顶层样式都已经被加载完毕，如果dom元素进行attach时，css元素并没有被加载完毕，则放置占位符，并在文档中标记，当样式表加载完毕，则重新进行计算。
说明，文档的渲染还是要等待顶层css加载完毕。接下来的gecko应该也是需要等待顶层css加载完毕，否则“css规则树”（见下文）无法建立啊  

#### Gecko  
webkit渲染是一个元素与样式规则匹配的过程，Gecko则需要构建样式计算规则书，然后与dom树对应生成样式上下文数（及渲染树）。   

解释一下：当遇到一个dom节点，例如：第二个div，根据css解析结果，进行规则匹配发现符合126这条规则线，我们发现，当遇到第一个div时已经匹配过12这条规则线，所以只需为规则6新增一个节点至样式上下文树的div：F节点。样式上下文树，是元素匹配样式的最终结果（原本是比例的也要换算成具体的px）。 Gecko利用样式规则树，有效的实现了样式共享。Webkit没有规则树，则需要对css解析结果进行多次遍历。出现多次的属性将会被按照正确的级联顺序进行处理最后一个生效。   

#### 优化
根据对计算样式困难的理解，我们在编写css样式表时应该注意一下：
1.dom深度尽量浅。  
2.减少inline javascript、css的数量。  
3.使用现代合法的css属性。  
4.不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。  
5.不要给类选择器指定标签，类，代表具有一类属性的标签，不仅是一个，虽然可以实现，但是降低了效率。
避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;#tp p{} 子选择符：#tp>p{}  
6.避免使用通配符，举一个例子，.mod .hd *{font-size:14px;} 根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配.hd（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配.mod,这样的性能耗费可想而知.  
### 优化关键路径渲染  
_优化关键渲染路径_就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间。 这样一来，就能尽快将内容渲染到屏幕上，此外还能缩短首次渲染后屏幕刷新的时间，即为交互式内容实现更高的刷新率。  

### 参考资料
[不同浏览器的渲染机制](http://blog.jobbole.com/12749/?repeat=w3tc)  
